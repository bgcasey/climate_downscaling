```{r setup, include=FALSE, cache=FALSE}
#Set root directory to R project root
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

setwd(rprojroot::find_rstudio_root_file())
```

```{r eval=FALSE}
library(tidyr)
library(plyr)
library(dplyr)
library(kableExtra)
library(lubridate)
library(imputeTS)
library(readr)
```

### Import and clean {.unnumbered}

#### RIVR {.unnumbered}

**Load data**

```{r}
RIVR<-read.csv(file="0_data/external/iButton/RIVR/iButtons_RIVR_combined_April7_2022_no_extremes.csv")
```

**Examine data frame**

Count the number of unique iButtons

```{r echo=FALSE, message = FALSE, results="asis"}
# count unique deployments
nrow(distinct(as.data.frame((RIVR$Site_StationKey))))
```

View data

```{r echo=FALSE, message = FALSE, results="asis"}
#RIVR<-read.csv(file="0_data/external/iButton/RIVR/iButtons_RIVR_combined_April7_2022_no_extremes.csv")
knitr::kable(head(RIVR), "pipe") 
```

##### Edit data columns {.unnumbered}

###### Format date-time string {.unnumbered}

Convert date-time string into a `POSIXct` class. This class associates the date time string with an associated time zone. Codes for time zones can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). Else the `as.POSIXct` function defaults to your computer's timezone.

```{r eval=FALSE}
RIVR$Date_Time<-as.POSIXct(RIVR$Date_Time, tz="America/Edmonton")
```

##### Remove unusable data {.unnumbered}

###### Remove months with incomplete data {.unnumbered}

Removing first month of data if it has only 20 days or less.

```{r eval=FALSE}
RIVR_1<- RIVR%>% split(f=.$New_Site_Key) %>% lapply(FUN=function(x){
  if (x %>% filter(month(Date_Time)==month(min(Date_Time))& year(Date_Time)==min(year(Date_Time))) %>%
      summarize(max(Day)-min(Day)) %>% c () < 20 ){
    y<-x %>% filter(month(Date_Time)>month(min(Date_Time))| year(Date_Time)> min(year(Date_Time)))    
    
    return(y)
  }else{
    return(x)
  }
}) 
```

Removing last month of data if it has only 20 days or less.

```{r eval=FALSE}
RIVR_2<-RIVR_1 %>% lapply(FUN=function(x){
  if (x %>% filter(month(Date_Time)==month(max(Date_Time))& year(Date_Time)==max(year(Date_Time))) %>% 
      summarize(max(Day)-min(Day)) %>% c () < 20 ){
    y<-x %>% filter(month(Date_Time)<month(max(Date_Time))| year(Date_Time)< max(year(Date_Time)))    
    
    #y<-x[!(month(x$Date_Time)==month(min(x$Date_Time) & year(x$Date_Time)==min(year(x$Date_Time)))),]
    return(y)
  }else{
    return(x)
  }
  
}) %>% do.call(rbind,.) #working

```

##### Remove pre-deployement data {.unnumbered}

```{r eval=FALSE}
RIVR_3<- RIVR_2%>%
  filter(Date_Time>Date_Time_dpl)%>%
  filter(Date_Time<Date_Time_rtv)

RIVR_cleaned<-RIVR_3
save(RIVR_cleaned, file="2_pipeline/tmp/RIVR_cleaned.rData")
```


##### Identify and remove data from grounded iButtons {.unnumbered}

##### Get daily temperature summaries {.unnumbered}

Create new calculated columns with the mean, max, and min daily temperatures and diurnal range. 

```{r eval=FALSE}
RIVR_3<-RIVR_cleaned %>% 
  mutate(Date=date(Date_Time))%>%
  dplyr::group_by(Site_StationKey,Day,Month,Year,Date, iBt_type)%>%  dplyr::mutate(Temperature=Value) %>%
  dplyr::summarize(Tmax_Day=max(Temperature),Tmin_Day=min(Temperature),Tavg_Day=mean(Temperature), T_diurnal=max(Temperature)-min(Temperature))%>% 
  dplyr::group_by(Site_StationKey,iBt_type,Month,Year) %>% dplyr::filter(!iBt_type=="EXTRA-TOP")%>%
  arrange(Site_StationKey, Date)

RIVR_dailys<-RIVR_3

save(RIVR_dailys, file="2_pipeline/store/RIVR_dailys.rData")
```



```{r echo=FALSE, message = FALSE, results="asis"}
load("2_pipeline/store/RIVR_dailys.rData")

knitr::kable(head(RIVR_dailys), "pipe") 
```





#### HILL {.unnumbered}

**Load data**

```{r}
hills<-read.csv(file="0_data/external/iButton/Hills/Hills_iButton_Data_Combined_Corrected_for_Deployment_no_extremes_Apr_27.csv")
```

**Examine data frame**

Count the number of unique iButtons

```{r echo=FALSE, message = FALSE, results="asis"}
# count unique deployments
nrow(distinct(as.data.frame((hills$Site_StationKey))))
```

View data

```{r echo=FALSE, message = FALSE, results="asis"}
#RIVR<-read.csv(file="0_data/external/iButton/RIVR/iButtons_RIVR_combined_April7_2022_no_extremes.csv")
knitr::kable(head(hills), "pipe") 
```

##### Edit data columns {.unnumbered}

###### Format date-time string {.unnumbered}

Convert date-time string into a `POSIXct` class. This class associates the date time string with an associated time zone. Codes for time zones can be found [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). Else the `as.POSIXct` function defaults to your computer's timezone.

```{r eval=FALSE}
hills$Date.Time<-as.POSIXct(hills$Date.Time, tz="America/Edmonton")
```

##### Remove unusable data {.unnumbered}

###### Remove months with incomplete data {.unnumbered}

Remove first and last months if they have less than 21 days of data.

```{r eval=FALSE}
hills_1<-hills %>%
  mutate(Value=Temperature,Month=month(Date.Time),Day=day(Date.Time),Year=year(Date.Time),
                Date_Time=Date.Time) %>%  
  ###Split per site_stationkey and remove first and last month if they have less than 20 days
  split(f=.$Site_StationKey) %>% lapply(FUN=function(x){
    if (x %>% filter(month(Date_Time)==month(min(Date_Time))& year(Date_Time)==min(year(Date_Time))) %>%
        summarize(max(Day)-min(Day)) %>% c () < 20 ){
      y<-x %>% filter(month(Date_Time)>month(min(Date_Time))| year(Date_Time)> min(year(Date_Time)))    
      
      return(y)
    }else{
      return(x)
    }
    
  }) %>% lapply(FUN=function(x){
    if (x %>% filter(month(Date_Time)==month(max(Date_Time))& year(Date_Time)==max(year(Date_Time))) %>% 
        summarize(max(Day)-min(Day)) %>% c () < 20 ){
      y<-x %>% filter(month(Date_Time)<month(max(Date_Time))| year(Date_Time)< max(year(Date_Time)))    
      
      #y<-x[!(month(x$Date_Time)==month(min(x$Date_Time) & year(x$Date_Time)==min(year(x$Date_Time)))),]
      return(y)
    }else{
      return(x)
    }
    
  }) %>% do.call(rbind,.) 


hills_cleaned<-hills_1
save(hills_cleaned, file="2_pipeline/tmp/hills_cleaned.rData")

```

##### Remove predeployement data {.unnumbered}

##### Get daily temperature summaries {.unnumbered}

Create new calculated columns with the mean, max, and min daily temperatures.

```{r eval=FALSE}
hills_2<-hills_1 %>%
  mutate(Date=date(Date_Time))%>%
  dplyr::group_by(Site_StationKey,Date) %>% #group by days, month and year
  dplyr::summarize(Tmax_Day=max(Temperature),Tmin_Day=min(Temperature),Tavg_Day=mean(Temperature))%>%
  mutate(Year=year(Date))%>%
  mutate(Month=month(Date))%>%
  mutate(Day=day(Date))%>%
  dplyr::group_by(Site_StationKey,Date) 

hills_dailys<-hills_2

save(hills_dailys, file="2_pipeline/store/hills_dailys.rData")
```

```{r echo=FALSE, message = FALSE, results="asis"}
load("2_pipeline/store/hills_dailys.rData")

knitr::kable(head(hills_dailys), "pipe") 
```


#### Wood {-} 

Data from Wood, Wendy H; Marshall, Shawn J; Fargey, Shannon E; Whitehead, Terri L (2017): Daily temperature data from the Foothills Climate Array Mesonet, Canadian Rocky Mountains, 2005-2010. PANGAEA, https://doi.org/10.1594/PANGAEA.880611. 

```{r eval=FALSE}
wood<-read.delim(file="0_data/external/iButton/WoodEtAl/Wood_etal_2017.tab",  header=T, sep="\t", skip = 23)
```


#### Alex {-}

```{r eval=FALSE}

# read csvs
alex_2019<-read_csv(file="0_data/external/iButton/alex/combined/Combined2019TempData.csv")
alex_2020_2021<-read_csv(file="0_data/external/iButton/alex/combined/Combined2020_2021TempData.csv")


# need to add a time column to alex_2020_2021
## read and rbind csvs



# read in the individidual 2020-2021 csvs
filenames=list.files(path="0_data/external/iButton/alex/individual/2020_2021", full.names=TRUE)
myMergedData <- 
    read_csv(filenames) %>% 
    bind_rows()
colnames(myMergedData)[1] <- "date_time"

# fix date and time fields 
alex_2020_2021a<-myMergedData%>%
  mutate(date_time=gsub("\\.","",myMergedData$date_time))%>%
  mutate(site_id=sub("\\(.*","",myMergedData$site_id))%>% # remove entore string after (
  mutate(site_id=gsub(" ", "", site_id, fixed = TRUE))%>% # remove white space
  mutate(site_id=gsub("(?<=\\d)(?=\\D)|(?<=\\D)(?=\\d)", "_", site_id, perl = TRUE)) %>% # add _ between digits and letters
  drop_na(c(date_time, date_time_deployed))%>%
  mutate(date_time_2=dmy_hm(date_time))%>%
  # mutate(date_time_3=replace_na(list(date_time_2), 0))%>%
  mutate(date_time_3 = ifelse(is.na(date_time_2), dmy_hms(date_time), date_time_2))%>%
  mutate(date_time_corrected= as_datetime(date_time_3))%>%
  # mutate(date_time_all=coalesce(date_time_2, date_time_3))%>%
  select(-c(date_time_2, date_time_3))%>%
  mutate(month=month(date_time_corrected))%>%
  mutate(day=day(date_time_corrected))%>%
  mutate(year=year(date_time_corrected))%>%
  mutate(date_time_deployed_1=dmy_hm(date_time_deployed))%>%
  mutate(date_time_deployed_2 = ifelse(is.na(date_time_deployed_1), dmy_hms(date_time_deployed), date_time_deployed_1))%>%
  mutate(date_time_deployed_corrected= as_datetime(date_time_deployed_2))%>%
  select(-c(date_time_deployed_2, date_time_deployed_1))%>%
  # mutate(date_time_deployed_1=dmy_hms(date_time_deployed))%>%
  arrange(temp_id, date_time_deployed_corrected)%>%
  filter(date_time_deployed_corrected<date_time_corrected)%>%
  distinct()
 
unique(alex_2020_2021$site_id)
# there are a lot more site id's here than on Alexs plot locations spreadsheet. 557 vs 97. Missing somthing? Some of the ids in the locations and elevations spreadsheet are missing from the data (e.g. 1_WA, 3_C)


alex_2020_2021_fin<-read_csv(file="0_data/external/iButton/alex/combined/Combined2020_2021TempData.csv")


test<-alex_2020_2021[c(4:5)]%>%distinct()
test2<-alex_2020_2021_fin%>%
  select(site_id, plot_id)%>%distinct()
test3<-alex_2019%>%
      select(8)%>%
      distinct()
```


### Combine datasets {.unnumbered}

#### **Bind dataframes**

```{r eval=FALSE}

ibuttons<-bind_rows("RIVR"=RIVR_dailys,"HILLS"=hills_dailys,.id="Project")

save(ibuttons, file="2_pipeline/tmp/ibuttons.rData")
```

### Impute missing data {.unnumbered}

#### Create a dummy iButton data frame

The data frame will have rows for every day during the time period the iButtons were deployed. Daily temperature columns will be filled with NA values.

Create a calendar for the time iButtons were deployed.

```{r eval=FALSE}
months <- 1:12

# create a data frame with the number of days per month
days <- days_in_month(months) %>% as.data.frame() %>% `colnames<-`("Days") %>%
  mutate(Month=row.names(.))


# create a list of months 
calendar<-apply(days,MARGIN = 1,FUN=function(x){
 seq(1:x)
  } 
 ) %>%
  lapply(.,FUN = unlist)


#create a calendar data frame with all of the days of the year for all stations. The dataframe will have columns for day, month,  and year and spans the time of the ibuttons
calendar_step1<-calendar %>% `names<-`(days$Month) %>% unlist() %>% as.data.frame() %>%
  `colnames<-`("Day") %>% mutate(Month_name=substr(rownames(.),1,3)) %>%
  left_join(data.frame(Month_name=month.abb,Month=months)) %>%
  expand_grid(.,Year=c(min(ibuttons$Year):max(ibuttons$Year)))
```

Create the dummy data frame that includes all of the days/year of the above calendar data frame with NA instead of temperature values.

```{r eval=FALSE}

calendar_final<-data.frame(ibuttons$Site_StationKey,ibuttons$Project) %>% unique() %>%`colnames<-` (c("Site_StationKey","Project")) %>%
  expand_grid(.,calendar_step1) %>% mutate(iBt_type=NA,Tmax_Day=NA,Tmin_Day=NA,Tavg_Day=NA) %>% split(f = .$Project)

calendar_final_f1<-calendar_final$HILLS %>% filter(Year %in% unique(ibuttons$Year[ibuttons$Project=="HILLS"])) 
calendar_final_f2<-calendar_final$RIVR %>% filter(Year %in% unique(ibuttons$Year[ibuttons$Project=="RIVR"]))
complete_final_f3<-bind_rows(calendar_final_f1,calendar_final_f2) %>% select(!c(Month_name,iBt_type,Project))
```

#### Remove months with too many missing days {.unnumbered}

We need to trim down the missing days for months in which up to 10 days of data are missing.

```{r eval=FALSE}

# create a data frame of days with missing data
missing_days<-anti_join(complete_final_f3 %>% ungroup,
          ibuttons %>% ungroup() %>% select(!c(iBt_type,Project)),
          by=c("Site_StationKey","Day","Month","Year"))



# count the number of missing days and remove iButton months that are missing over 10 days of data
missing_of_importance<-missing_days %>% group_by(Site_StationKey,Month,Year) %>%
  summarize(count=n()) %>% filter(count<11) %>% mutate(keep="TRUE")

missing_days_final<-left_join(missing_days,missing_of_importance,by=c("Site_StationKey","Month","Year")) %>%
  filter(keep=="TRUE") %>% select(-c(count,keep))

#### Final iButton data frame with missing days {-}

complete_data_w_missing<-ibuttons %>% ungroup() %>% select(!c(iBt_type,Project)) %>%
  bind_rows(missing_days_final)

# create a column with the season
complete_data_w_missing_summer<- complete_data_w_missing %>% filter(Month %in% c(6,7,8))
complete_data_w_missing_winter<- complete_data_w_missing %>% filter(Month %in% c(12,1,2))
complete_data_w_missing_fall<- complete_data_w_missing %>% filter(Month %in% c(9,10,11))
complete_data_w_missing_spring<- complete_data_w_missing %>% filter(Month %in% c(3,4,5))

ib_cal<-bind_rows("Summer"=complete_data_w_missing_summer,
          "Winter"=complete_data_w_missing_winter,"Fall"=complete_data_w_missing_fall,"Spring"=complete_data_w_missing_spring, .id="Season")

```


#### Impute missing values {.unnumbered}

Impute NA values using a spline function based on time series imputation. The imputation is based on month per year per iButton site.

```{r eval=FALSE}

inputted_summer<-ddply(complete_data_w_missing_summer,.(Site_StationKey,Month,Year),.fun = 
        function(x){
          na_interpolation(x,option="spline")
        })


inputted_winter<-ddply(complete_data_w_missing_winter,.(Site_StationKey,Month,Year),.fun = 
                         function(x){
                           na_interpolation(x,option="spline")
                         })
inputted_fall<-ddply(complete_data_w_missing_fall,.(Site_StationKey,Month,Year),.fun = 
                         function(x){
                           na_interpolation(x,option="spline")
                         })


inputted_spring<-ddply(complete_data_w_missing_spring,.(Site_StationKey,Month,Year),.fun = 
                         function(x){
                           na_interpolation(x,option="spline")
                         })


complete_data<-bind_rows(inputted_summer,inputted_winter,inputted_fall,inputted_spring)

#save
ibuttons_complete_daily<-complete_data
save(ibuttons_complete_daily, file="0_data/manual/iButton_data/ibuttons_complete_daily.rData")

write.csv(ibuttons_complete_daily, file="0_data/manual/iButton_data/ibuttons_complete_daily.csv")

```








### Monthly summaries {.unnumbered}

```{r eval=FALSE}
load("0_data/manual/iButton_data/ibuttons_complete_daily.rData")
ibuttons_complete_monthly<-ibuttons_complete_daily %>%
        group_by(Site_StationKey,Month,Year)%>%
        select(-Day)%>%
        summarise_all(list(mean))%>%
        arrange(Site_StationKey, Year, Month)%>%
        rename(c(Tmax_Month=Tmax_Day, Tmin_Month=Tmin_Day, Tavg_Month=Tavg_Day))
  
save(ibuttons_complete_monthly, file="0_data/manual/iButton_data/ibuttons_complete_monthly.rData")

write.csv(ibuttons_complete_monthly, file="0_data/manual/iButton_data/ibuttons_complete_monthly.csv")
```

```{r echo=FALSE, message = FALSE, results="asis"}
load("0_data/manual/iButton_data/ibuttons_complete_monthly.rData")

knitr::kable(head(ibuttons_complete_monthly), "pipe") 
```



